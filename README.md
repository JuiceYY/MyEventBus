# MyEventBus
实现了一个简单的事件总线EventBus
> EventBus是一个基于观察者模式的事件发布/订阅框架, 可以方便的实现不同组件之间的通信, 比使用Handler和接口回调更加方便, 比广播更加节省性能

## EventBus的基本原理
- EventBus在整个应用中只有一个单例, 它维护一个集合, 保存了所有订阅了事件的对象和其方法, 当有某个事件发出时, 遍历集合找出所有与该事件匹配的方法用反射执行
- 安卓中几乎不可避免要用到子线程去执行耗时操作, 事件的发布和订阅可能不在同一线程, 所以我们要能够指定事件订阅在主线程还是子线程

## 实现步骤
1. 定义订阅方法需要加的注解@MySubscriber, 注解中需要传入事件订阅在哪个线程, 默认为主线程

2. 封装一个方法类, 用来保存订阅事件的方法,方法参数类型, 及方法订阅的线程的信息, 某个对象注册后遍历方法信息存在EventBus中

```
public class SubscriberMethod {

    private Method method;
    private Class<?> paramType;
    private ThreadMode threadMode;
    
    ... 
    
}
```

3. 注册 register(Object obj)

- 首先, EventBus需要维护一个Map, 键为注册事件总线的对象, 值为订阅的方法信息
- 在注册方法中, 需要通过反射遍历注册对象的方法信息, 找到所有我们注解标记的方法, 将方法信息封装成自定义的方法类后, 把注册的对象和方法信息存储到Map中

4. 发布事件 post(Event event)

- 使用EventBus发布事件后, 遍历Map中的方法信息, 找到参数类型相同的方法利用反射执行
> EventBus使用发布的事件的类型确定哪些方法会被执行
- 线程切换: 事件发布在子线程订阅在主线程可以用Handler实现, 发布在主线程订阅在子线程可以用线程池实现, 发布线程和订阅线程在同一线程时不用做线程的切换

5. 反注册 unregister(Object obj)
> 如果没有反注册的话, EventBus中的Map会越来越大
- 某个对象反注册后, 在map中删除所有以该对象为键的键值对


